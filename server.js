require('dotenv').config();
const express = require('express');
const cors = require('cors');
const path = require('path');

const multer = require('multer');
const QRCode = require('qrcode');
const generatePayload = require('promptpay-qr');
const ESYSlipService = require('./esy-slip');

// Setup multer for file upload
const upload = multer({
    limits: { fileSize: 5 * 1024 * 1024 }, // 5MB max
    fileFilter: (req, file, cb) => {
        if (file.mimetype.startsWith('image/')) {
            cb(null, true);
        } else {
            cb(new Error('Only image files are allowed'));
        }
    }
});

// Initialize ESY Slip service
const esySlip = new ESYSlipService(process.env.ESY_SLIP_API_KEY);

// ‡πÄ‡∏û‡∏¥‡πà‡∏° debug log
console.log('ENV Check:');
console.log('REPLICATE_API_TOKEN:', process.env.REPLICATE_API_TOKEN ? 'Found ‚úì' : 'Not found ‚úó');
console.log('ASSISTANT_ID:', process.env.ASSISTANT_ID);
console.log('CHARACTER_ASSISTANT_ID:', process.env.CHARACTER_ASSISTANT_ID);
console.log('MULTI_CHARACTER_ASSISTANT_ID:', process.env.MULTI_CHARACTER_ASSISTANT_ID);
console.log('Loading .env from:', path.resolve(__dirname, '.env'));
console.log('ASSISTANT_ID:', process.env.ASSISTANT_ID);

// Import modules
const assistants = require('./assistants');
const chatAI = require('./chat-ai');
let db = null;
try {
    db = require('./database');
    console.log('‚úÖ Database module loaded');
} catch (error) {
    console.log('‚ö†Ô∏è  Database module not found, running without rate limiting');
}

const app = express();
const PORT = process.env.PORT || 3000;

// Settings
const DAILY_LIMIT_THB = 5.0;  // 5 ‡∏ö‡∏≤‡∏ó/‡∏Ñ‡∏ô/‡∏ß‡∏±‡∏ô
const COST_PER_1K_TOKENS = 0.02; // ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì 0.02 ‡∏ö‡∏≤‡∏ó/1K tokens

// Store user threads (in production, use Redis or database)
const userThreads = new Map();

// Middleware
app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use(express.static('public'));

// Serve admin page (optional - ‡∏ñ‡πâ‡∏≤ static ‡πÑ‡∏°‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô)
app.get('/admin', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'admin.html'));
});

// ======== ADMIN ENDPOINTS ========
const ADMIN_KEY = process.env.ADMIN_SECRET_KEY || 'your-secret-admin-key-2025';

function checkAdminAuth(req, res, next) {
    const adminKey = req.headers['x-admin-key'];
    if (!adminKey || adminKey !== ADMIN_KEY) {
        return res.status(401).json({ error: 'Unauthorized' });
    }
    next();
}

app.post('/api/admin/add-credits', checkAdminAuth, async (req, res) => {
    const { userId, amount, note } = req.body;
    
    if (!userId || !amount || amount <= 0) {
        return res.status(400).json({ error: 'Invalid parameters' });
    }
    
    try {
        if (!db) {
            return res.status(500).json({ error: 'Database not available' });
        }
        
        const result = await db.addCredits(
            userId,
            amount,
            '‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏ú‡πà‡∏≤‡∏ô PromptPay',
            null,
            note || 'Manual credit addition'
        );
        
        if (result.success) {
            res.json({
                success: true,
                newBalance: result.newBalance,
                message: `Added ${amount} credits to ${userId}`
            });
        } else {
            res.status(400).json({ error: result.error });
        }
    } catch (error) {
        console.error('Error adding credits:', error);
        res.status(500).json({ error: 'Failed to add credits' });
    }
});

// Calculate cost
function calculateCost(usage) {
    const totalTokens = (usage.prompt_tokens || 0) + (usage.completion_tokens || 0);
    return (totalTokens / 1000) * COST_PER_1K_TOKENS;
}

// Test route
app.get('/test', (req, res) => {
    res.json({ 
        status: 'Server is working!',
        hasApiKey: !!process.env.OPENAI_API_KEY && process.env.OPENAI_API_KEY !== 'demo-key',
        hasAssistantId: !!process.env.ASSISTANT_ID,
        hasCharacterAssistantId: !!process.env.CHARACTER_ASSISTANT_ID,
        hasDatabase: !!db
    });
});

// Chat endpoint using Assistants API
app.post('/api/chat', async (req, res) => {
    const { message, userId = 'guest', images = [], mode = 'general' } = req.body;
    let shouldUseCredits = false;

    // Check configuration
    if (!process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY === 'demo-key') {
        return res.json({ 
            response: 'Demo Mode: ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ OpenAI API Key ‡πÉ‡∏ô Railway Variables',
            isDemo: true 
        });
    }

    // Select assistant based on mode
    let assistantId;
    if (mode === 'character') {
        assistantId = process.env.CHARACTER_ASSISTANT_ID;
        if (!assistantId) {
            return res.status(500).json({ 
                error: 'Character Assistant ID not configured'
            });
        }
    } else {
    console.log('General mode - ASSISTANT_ID:', process.env.ASSISTANT_ID);
    assistantId = process.env.ASSISTANT_ID || 'asst_p1ZxkTa5US7Yn1GgUSy8sNy9';
        if (!assistantId) {
            return res.status(500).json({ 
                error: 'Assistant ID not configured'
            });
        }
    }

    try {
        // Check daily limit if database is available
        if (db) {
            const todayUsage = await db.getTodayUsage(userId);
            
            const estimatedCost = 0.10; // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡∏ô‡∏µ‡πâ
const estimatedTotal = todayUsage + estimatedCost; // ‡πÅ‡∏Å‡πâ‡∏à‡∏≤‡∏Å 0.05 ‡πÄ‡∏õ‡πá‡∏ô estimatedCost

if (estimatedTotal > DAILY_LIMIT_THB) {
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏´‡∏£‡πà (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏ô 5 ‡∏ö‡∏≤‡∏ó)
    const creditsNeeded = estimatedTotal - DAILY_LIMIT_THB;
    const userCredits = await db.getUserCredits(userId);
    
    if (userCredits < creditsNeeded) {  // ‡πÅ‡∏Å‡πâ‡∏à‡∏≤‡∏Å estimatedCost ‡πÄ‡∏õ‡πá‡∏ô creditsNeeded
        // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡∏û‡∏≠
        return res.status(429).json({
            error: 'Insufficient credits',
            message: '‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏ï‡∏¥‡∏°‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï',
            credits: {
                current: userCredits.toFixed(2),
                required: estimatedCost.toFixed(2)
            },
            usage: {
                used: todayUsage.toFixed(2),
                limit: DAILY_LIMIT_THB,
                wouldBe: estimatedTotal.toFixed(2)
            }
        });
    }
    
    // ‡∏°‡∏µ‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡∏û‡∏≠ - ‡∏à‡∏∞‡∏´‡∏±‡∏Å‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á prompt ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
    // ‡∏ï‡∏±‡πâ‡∏á flag ‡πÑ‡∏ß‡πâ‡∏Å‡πà‡∏≠‡∏ô
    shouldUseCredits = true;  // ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ var ‡∏´‡∏£‡∏∑‡∏≠ let
}
        }

        // ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏î‡∏¥‡∏°‡∏î‡πâ‡∏ß‡∏¢‡πÇ‡∏Ñ‡πâ‡∏î‡∏ô‡∏µ‡πâ

// Get or create thread with error handling
const threadKey = `${userId}_${mode}`;
let threadId = userThreads.get(threadKey);
let retryCount = 0;
const maxRetries = 2;

// Function to create new thread
const createNewThread = async () => {
    try {
        threadId = await assistants.createThread();
        userThreads.set(threadKey, threadId);
        console.log(`‚úÖ New thread created for ${userId}: ${threadId}`);
        return threadId;
    } catch (err) {
        console.error('‚ùå Failed to create thread:', err);
        throw err;
    }
};

// Try to use existing thread or create new one
while (retryCount < maxRetries) {
    try {
        if (!threadId) {
            console.log('üìå No thread found, creating new one...');
            threadId = await createNewThread();
        }

        // Try to add message
        console.log('üì® Adding message to thread...');
        await assistants.addMessage(threadId, message, images);
        
        // If successful, break the loop
        console.log('‚úÖ Message added successfully');
        break;

    } catch (error) {
        console.error(`‚ùå Error adding message (attempt ${retryCount + 1}):`, error.message);
        
        // If thread is expired or invalid
        if (error.message.includes("Can't add messages to thread") || 
            error.message.includes("No thread found") ||
            error.message.includes("No assistant found") ||
            error.status === 400 || 
            error.status === 404) {
            
            console.log('üîÑ Thread expired or invalid, creating new thread...');
            
            // Delete old thread reference
            userThreads.delete(threadKey);
            
            // Create new thread
            if (retryCount < maxRetries - 1) {
                threadId = await createNewThread();
                retryCount++;
            } else {
                throw new Error('Failed to create valid thread after retries');
            }
        } else {
            // Other errors, don't retry
            throw error;
        }
    }
}

        // Add message to thread
        await assistants.addMessage(threadId, message, images);

        // Run assistant and get response
        const result = await assistants.runAssistant(threadId, assistantId);

        // Calculate cost
        const costTHB = calculateCost(result.usage);
        let todayTotal = costTHB;

        // Save usage if database is available
        if (db) {
    console.log(`üí∞ === PROMPT GENERATION COST ===`);
    console.log(`üí∞ Mode: ${mode}`);
    console.log(`üí∞ Cost: ‡∏ø${costTHB.toFixed(2)}`);
    
    // ‡πÉ‡∏ä‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡πÉ‡∏´‡∏°‡πà
    const creditResult = await db.useCreditsNew(
        userId,
        costTHB,
        `${mode} prompt generation`
    );
    
    if (creditResult.success) {
        console.log(`‚úÖ Used ‡∏ø${costTHB.toFixed(2)}:`);
        console.log(`   - From free: ‡∏ø${creditResult.used_from_free.toFixed(2)}`);
        console.log(`   - From paid: ‡∏ø${creditResult.used_from_paid.toFixed(2)}`);
        console.log(`   - Free remaining: ‡∏ø${creditResult.free_remaining.toFixed(2)}`);
        console.log(`   - Paid remaining: ‡∏ø${creditResult.paid_remaining.toFixed(2)}`);
        
        // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
        todayTotal = DAILY_LIMIT_THB - creditResult.free_remaining;
    } else {
        console.error('‚ùå Failed to deduct credits:', creditResult.error);
        // ‡∏ñ‡πâ‡∏≤‡∏´‡∏±‡∏Å‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡πÉ‡∏´‡πâ‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
        return res.status(429).json({
            error: 'Insufficient credits',
            message: '‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠',
            credits: {
                current: creditResult.paid_remaining || 0,
                required: costTHB
            }
        });
    }
}

        // Send response
        res.json({
            response: result.response,
            mode: mode,
            usage: {
                tokens: {
                    input: result.usage.prompt_tokens,
                    output: result.usage.completion_tokens,
                    total: result.usage.total_tokens
                },
                cost: {
                    this_request: costTHB.toFixed(2),
                    today_total: todayTotal.toFixed(2),
                    daily_limit: DAILY_LIMIT_THB.toFixed(2),
                    remaining: (DAILY_LIMIT_THB - todayTotal).toFixed(2)
                }
            }
        });

    } catch (error) {
    console.error('‚ùå Chat error:', error);
    
    // Special handling for thread errors
    if (error.message.includes('thread') || 
        error.message.includes('Thread') ||
        error.message.includes('assistant')) {
        
        // Clear the thread for this user
        const threadKey = `${userId}_${mode}`;
        userThreads.delete(threadKey);
        
        console.log('üîÑ Cleared expired thread for user:', userId);
        
        return res.status(500).json({ 
            error: 'Session expired. Please try again.',
            details: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á',
            shouldRetry: true,
            clearThread: true
        });
    }
    
    // Handle other errors
    res.status(500).json({ 
        error: 'Failed to generate response',
        details: error.message 
    });
}
});

// Character Library Endpoints

// Get all characters for a user
app.get('/api/characters/:userId', async (req, res) => {
    const { userId } = req.params;
    
    try {
        if (!db) {
            return res.json([]);
        }
        
        const characters = await db.getCharacters(userId);
        res.json(characters);
    } catch (error) {
        console.error('Error getting characters:', error);
        res.status(500).json({ error: 'Failed to get characters' });
    }
});

// Save new character
app.post('/api/characters', async (req, res) => {
    const { userId, name, profile, preview } = req.body;
    
    try {
        if (!db) {
            return res.status(500).json({ error: 'Database not available' });
        }
        
        const characterId = await db.saveCharacter(userId, name, profile, preview);
        res.json({ 
            success: true, 
            characterId 
        });
    } catch (error) {
        console.error('Error saving character:', error);
        res.status(500).json({ error: 'Failed to save character' });
    }
});

// Delete character
app.delete('/api/characters/:characterId', async (req, res) => {
    const { characterId } = req.params;
    
    try {
        if (!db) {
            return res.status(500).json({ error: 'Database not available' });
        }
        
        await db.deleteCharacter(characterId);
        res.json({ success: true });
    } catch (error) {
        console.error('Error deleting character:', error);
        res.status(500).json({ error: 'Failed to delete character' });
    }
});

// Save rating endpoint
// ========== RATING ENDPOINTS ==========
app.post('/api/ratings', async (req, res) => {
    const { userId, promptId, promptText, responseText, rating, feedback, mode } = req.body;
    
    try {
        if (!db) {
            return res.status(500).json({ error: 'Database not available' });
        }
        
        if (rating < 1 || rating > 5) {
            return res.status(400).json({ error: 'Invalid rating' });
        }
        
        await db.saveRating(userId, promptId, promptText, responseText, rating, feedback, mode);
        const avgRating = await db.getUserAverageRating(userId);
        
        res.json({ 
            success: true,
            averageRating: avgRating
        });
    } catch (error) {
        console.error('Error saving rating:', error);
        res.status(500).json({ error: 'Failed to save rating' });
    }
});

app.get('/api/ratings/:userId', async (req, res) => {
    const { userId } = req.params;
    const { limit = 10 } = req.query;
    
    try {
        if (!db) {
            return res.json({ ratings: [], stats: {} });
        }
        
        const ratings = await db.getUserRatings(userId, limit);
        const stats = await db.getRatingStats(userId);
        
        res.json({ ratings, stats });
    } catch (error) {
        console.error('Error getting ratings:', error);
        res.status(500).json({ error: 'Failed to get ratings' });
    }
});

// Reset thread endpoint (optional)
app.post('/api/reset/:userId', (req, res) => {
    const { userId } = req.params;
    const { mode = 'general' } = req.body;
    
    const threadKey = `${userId}_${mode}`;
    if (userThreads.has(threadKey)) {
        const threadId = userThreads.get(threadKey);
        assistants.deleteThread(threadId); // Clean up old thread
        userThreads.delete(threadKey);
    }
    
    res.json({ message: 'Thread reset successfully' });
});

// Get usage stats
app.get('/api/usage/:userId', async (req, res) => {
    const { userId } = req.params;
    
    try {
        if (!db) {
            return res.json({
                userId,
                today: {
                    used: 0,
                    limit: DAILY_LIMIT_THB,
                    remaining: DAILY_LIMIT_THB,
                    requests: 0,
                    percentUsed: 0
                },
                history: []
            });
        }

        // ‡∏î‡∏∂‡∏á‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡∏ü‡∏£‡∏µ‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà
        const freeCredits = await db.getFreeCredits(userId);
        const usedToday = DAILY_LIMIT_THB - freeCredits; // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ß‡πà‡∏≤‡πÉ‡∏ä‡πâ‡πÑ‡∏õ‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏´‡∏£‡πà
        
        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö history
        const stats = await db.getUsageStats(userId);
        
        res.json({
            userId,
            today: {
                used: usedToday.toFixed(2),
                limit: DAILY_LIMIT_THB.toFixed(2),
                remaining: freeCredits.toFixed(2), // ‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡∏ü‡∏£‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠
                requests: stats.today.requests || 0,
                percentUsed: ((usedToday / DAILY_LIMIT_THB) * 100).toFixed(0)
            },
            history: stats.week
        });
    } catch (error) {
        console.error('Error getting usage:', error);
        res.status(500).json({ error: 'Failed to get usage data' });
    }
});

// ========== ENHANCE PROMPT ENDPOINT ==========
app.post('/api/enhance-prompt', async (req, res) => {
    const { prompt, userId = 'guest' } = req.body;
    const assistantId = process.env.IMAGE_ENHANCE_ASSISTANT_ID || 'asst_fTpI5G9WTb9hUS165JsyDP94';
    
    if (!prompt) {
        return res.status(400).json({ error: 'Prompt is required' });
    }
    
    // Check API key
    if (!process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY === 'demo-key') {
        return res.json({ 
            enhancedPrompt: prompt + ' (Demo mode - no enhancement)',
            isDemo: true 
        });
    }
    
    try {
        // Check daily limit
        let shouldUseCredits = false;
        const estimatedCost = 0.05;
        
        if (db) {
            const todayUsage = await db.getTodayUsage(userId);
            const estimatedTotal = todayUsage + estimatedCost;
            
            if (estimatedTotal > DAILY_LIMIT_THB) {
                const creditsNeeded = estimatedTotal - DAILY_LIMIT_THB;
                const userCredits = await db.getUserCredits(userId);
                
                if (userCredits < creditsNeeded) {
                    return res.status(429).json({
                        error: 'Insufficient credits',
                        message: '‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠',
                        credits: {
                            current: userCredits.toFixed(2),
                            required: estimatedCost.toFixed(2)
                        }
                    });
                }
                shouldUseCredits = true;
            }
        }
        
        // Create thread and run assistant
        const threadId = await assistants.createThread();
        await assistants.addMessage(threadId, prompt, []);
        const result = await assistants.runAssistant(threadId, assistantId);
        
        // Clean up thread
        await assistants.deleteThread(threadId);
        
        // Calculate cost and save usage
        const costTHB = calculateCost(result.usage);
        
        if (db) {
            await db.saveUsage(userId, result.usage.prompt_tokens, result.usage.completion_tokens, costTHB);
            
            // ‡∏´‡∏±‡∏Å‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡∏ñ‡πâ‡∏≤‡πÉ‡∏ä‡πâ‡πÄ‡∏Å‡∏¥‡∏ô daily limit
            // ‚ö†Ô∏è ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ mode ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ
            if (shouldUseCredits) {
                const latestUsage = await db.getTodayUsage(userId);
                const overLimitAmount = Math.max(0, latestUsage - DAILY_LIMIT_THB);
                
                if (overLimitAmount > 0) {
                    await db.useCredits(
                        userId, 
                        overLimitAmount, 
                        'Enhance prompt - exceeded daily limit'  // ‚Üê ‡πÅ‡∏Å‡πâ‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
                    );
                }
            }
        }
        
        // Send response
        res.json({
            enhancedPrompt: result.response,
            usage: {
                tokens: result.usage.total_tokens,
                cost: costTHB.toFixed(2)
            }
        });
        
    } catch (error) {
        console.error('Enhance prompt error:', error);
        res.status(500).json({ 
            error: 'Failed to enhance prompt',
            details: error.message 
        });
    }
});

// ========== AI CHAT ENDPOINT ==========
app.post('/api/ai-chat', async (req, res) => {
    const { message, userId = 'guest', model = 'gpt-3.5-turbo', images = [], history = [] } = req.body;
    
    console.log('ü§ñ AI Chat request:', { userId, model, hasImages: images.length > 0 });
    
    // Validate input
    if (!message && images.length === 0) {
        return res.status(400).json({ 
            error: 'Message or image is required' 
        });
    }
    
    try {
        // 1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï
        if (db) {
            // ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ tokens (‡∏Ñ‡∏£‡πà‡∏≤‡∏ß‡πÜ)
            const estimatedTokens = 500; // ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì 500 tokens ‡∏ï‡πà‡∏≠‡∏Ñ‡∏£‡∏±‡πâ‡∏á
            const estimatedCost = chatAI.calculateCostTHB(
                estimatedTokens / 2,  // input
                estimatedTokens / 2,  // output
                model
            );
            
            console.log(`üí∞ Estimated cost: ‡∏ø${estimatedCost.toFixed(2)}`);
            
            // ‡πÉ‡∏ä‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡πÉ‡∏´‡∏°‡πà
            const creditCheck = await db.getUserCredits(userId);
            const freeCredits = await db.getFreeCredits(userId);
            const totalAvailable = creditCheck + freeCredits;
            
            if (totalAvailable < estimatedCost) {
                return res.status(429).json({
                    error: 'Insufficient credits',
                    message: '‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠',
                    credits: {
                        current: totalAvailable.toFixed(2),
                        required: estimatedCost.toFixed(2)
                    }
                });
            }
        }
        
        // 2. ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° messages array
        const messages = [
            {
                role: 'system',
                content: 'You are a helpful AI assistant. ‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏õ‡πá‡∏ô AI ‡∏ú‡∏π‡πâ‡∏ä‡πà‡∏ß‡∏¢‡∏ó‡∏µ‡πà‡∏û‡∏π‡∏î‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢‡πÑ‡∏î‡πâ ‡∏ï‡∏≠‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÅ‡∏ö‡∏ö‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏±‡∏ô‡πÄ‡∏≠‡∏á'
            }
        ];
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏° history (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
        if (history.length > 0) {
            // ‡πÄ‡∏≠‡∏≤‡πÅ‡∏Ñ‡πà 10 ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
            const recentHistory = history.slice(-10);
            messages.push(...recentHistory);
        }
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏° message ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
        messages.push({
            role: 'user',
            content: message || '‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏£‡∏π‡∏õ‡∏ô‡∏µ‡πâ‡πÉ‡∏´‡πâ‡∏´‡∏ô‡πà‡∏≠‡∏¢'
        });
        
        // 3. ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ AI
        console.log('üì® Sending to AI...');
        const result = await chatAI.chat(model, messages, images);
        
        // 4. ‡∏´‡∏±‡∏Å‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï
        if (db) {
            const actualCost = result.costTHB;
            console.log(`üí∞ Actual cost: ‡∏ø${actualCost.toFixed(4)}`);
            
            // ‡πÉ‡∏ä‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡πÉ‡∏´‡∏°‡πà
            const creditResult = await db.useCreditsNew(
                userId,
                actualCost,
                `AI Chat - ${model}`
            );
            
            if (!creditResult.success) {
                console.error('Failed to deduct credits:', creditResult.error);
            }
        }
        
        // 5. ‡∏™‡πà‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏•‡∏±‡∏ö
        res.json({
            success: true,
            response: result.content,
            model: result.model,
            usage: result.usage,
            cost: result.costTHB
        });
        
    } catch (error) {
        console.error('AI Chat error:', error);
        res.status(500).json({ 
            error: 'Failed to process chat',
            details: error.message 
        });
    }
});

// ========== IMAGE GENERATION ENDPOINT ==========
app.post('/api/generate-image', async (req, res) => {
    const { prompt, userId, model = 'flux-schnell', aspectRatio = '1:1' } = req.body;
    
    // Check if Replicate API key exists
    if (!process.env.REPLICATE_API_TOKEN) {
        return res.status(500).json({ 
            error: 'Replicate API key not configured' 
        });
    }
    
    // Model pricing
    const modelPricing = {
        'flux-schnell': 0.15,
        'flux-dev': 0.20,
        'sdxl-lightning': 0.50
    };
    
    const cost = modelPricing[model] || 0.15;
    
    try {
        // Check daily limit and credits
        if (db) {
            const todayUsage = await db.getTodayUsage(userId);
            const dailyRemaining = Math.max(0, 5 - todayUsage);
            
            if (dailyRemaining >= cost) {
                // Use daily limit
                console.log('Using daily limit');
            } else {
                // Need to use credits
                const creditsNeeded = cost - dailyRemaining;
                const userCredits = await db.getUserCredits(userId);
                
                if (userCredits < creditsNeeded) {
                    return res.status(429).json({
                        error: 'Insufficient credits',
                        message: '‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠',
                        credits: {
                            current: userCredits.toFixed(2),
                            required: creditsNeeded.toFixed(2)
                        }
                    });
                }
            }
        }
        
        try {
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á prediction ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£ run ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
    const Replicate = require('replicate');
    const replicate = new Replicate({
        auth: process.env.REPLICATE_API_TOKEN
    });
    
    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î model version ‡∏ï‡∏≤‡∏° model ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
    let modelVersion = '';
    if (model === 'flux-schnell') {
        modelVersion = 'black-forest-labs/flux-schnell';
    } else if (model === 'flux-dev') {
        modelVersion = 'black-forest-labs/flux-dev';
    } else {
        modelVersion = 'playgroundai/playground-v2.5-1024px-aesthetic:42fe626e41cc811eaf02c94b892774839268ce1994ea778eba97103fe1ef51b8';
}
    
    console.log('Creating prediction for:', modelVersion);
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á prediction
    const prediction = await replicate.predictions.create({
        model: modelVersion,
        input: {
            prompt: prompt,
            aspect_ratio: aspectRatio || '1:1',
            output_format: 'webp',
            output_quality: 90
        }
    });
    
    console.log('Prediction created:', prediction.id);
    
    // ‡∏£‡∏≠‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
    let result = prediction;
    while (result.status !== 'succeeded' && result.status !== 'failed') {
        await new Promise(resolve => setTimeout(resolve, 1000)); // ‡∏£‡∏≠ 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
        result = await replicate.predictions.get(prediction.id);
        console.log('Status:', result.status);
    }
    
    if (result.status === 'succeeded') {
        const imageUrl = result.output[0] || result.output;
        console.log('Image URL:', imageUrl);
        
        // Save usage ‡πÅ‡∏•‡∏∞‡∏´‡∏±‡∏Å‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï
if (db) {
    console.log(`üí∞ === NEW CREDIT SYSTEM ===`);
    console.log(`üí∞ Image cost: ‡∏ø${cost}`);
    
    // ‡πÉ‡∏ä‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà
    const creditResult = await db.useCreditsNew(
        userId,
        cost,
        `Image generation - ${model}`
    );
    
    if (creditResult.success) {
        console.log(`‚úÖ Used ‡∏ø${cost}:`);
        console.log(`   - From free: ‡∏ø${creditResult.used_from_free.toFixed(2)}`);
        console.log(`   - From paid: ‡∏ø${creditResult.used_from_paid.toFixed(2)}`);
        console.log(`   - Free remaining: ‡∏ø${creditResult.free_remaining.toFixed(2)}`);
        console.log(`   - Paid remaining: ‡∏ø${creditResult.paid_remaining.toFixed(2)}`);
    } else {
        console.error('‚ùå Failed to deduct credits:', creditResult.error);
    }
}
        
        res.json({
            success: true,
            imageUrl: imageUrl,
            model: model,
            cost: cost
        });
    } else {
        throw new Error('Image generation failed');
    }
    
} catch (error) {
    console.error('Image generation error:', error);
    res.status(500).json({ 
        error: 'Failed to generate image',
        details: error.message 
    });
}
        
    } catch (error) {
        console.error('Image generation error:', error);
        res.status(500).json({ 
            error: 'Failed to generate image',
            details: error.message 
        });
    }
});

// ======== CREDIT SYSTEM ENDPOINTS ========

// Endpoint ‡∏î‡∏π‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥
app.get('/api/credits/:userId', async (req, res) => {
    const { userId } = req.params;
    
    try {
        const credits = await db.getUserCredits(userId);
        const history = await db.getCreditHistory(userId);
        
        res.json({
            currentCredits: credits,
            history: history
        });
    } catch (error) {
        console.error('Error getting credits:', error);
        res.status(500).json({ error: 'Failed to get credits' });
    }
});

// Endpoint ‡∏î‡∏π‡πÅ‡∏û‡πá‡∏Ñ‡πÄ‡∏Å‡∏à
app.get('/api/credit-packages', async (req, res) => {
    try {
        const packages = await db.getCreditPackages();
        res.json(packages);
    } catch (error) {
        console.error('Error getting packages:', error);
        res.status(500).json({ error: 'Failed to get packages' });
    }
});

// Endpoint ‡πÄ‡∏ï‡∏¥‡∏°‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï (Manual - ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Admin)
app.post('/api/credits/manual-add', async (req, res) => {
    const { userId, amount, note } = req.body;
    
    // TODO: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå admin
    
    try {
        const result = await db.addCredits(
            userId, 
            amount, 
            'Manual credit adjustment',
            null,
            note
        );
        
        if (result.success) {
            res.json({
                success: true,
                newBalance: result.newBalance
            });
        } else {
            res.status(400).json({ error: result.error });
        }
    } catch (error) {
        console.error('Error adding credits:', error);
        res.status(500).json({ error: 'Failed to add credits' });
    }
});

// ========== SLIP VERIFICATION ENDPOINT ==========
// ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á endpoint ‡∏ô‡∏µ‡πâ (‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î 1193-1318)
app.post('/api/verify-slip', upload.single('slip'), async (req, res) => {
    console.log('üì§ Slip verification request received');
    
    // Debug: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö API Key
    console.log('üîë ESY API Key exists:', !!process.env.ESY_SLIP_API_KEY);
    console.log('üîë ESY API Key length:', process.env.ESY_SLIP_API_KEY?.length);
    console.log('üîë ESY API Key first 10 chars:', process.env.ESY_SLIP_API_KEY?.substring(0, 10) + '...');
    
    try {
        // Check if file was uploaded
        if (!req.file) {
            return res.status(400).json({ 
                error: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏™‡∏•‡∏¥‡∏õ' 
            });
        }
        
        const { userId, packageId, expectedAmount } = req.body;
        
        // Validate inputs
        if (!userId || !packageId || !expectedAmount) {
            return res.status(400).json({ 
                error: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô' 
            });
        }
        
        console.log('üìã Verification details:', {
            userId,
            packageId,
            expectedAmount,
            fileSize: req.file.size,
            fileType: req.file.mimetype,
            fileName: req.file.originalname
        });
        
        // Convert file to base64
        const slipData = `data:${req.file.mimetype};base64,${req.file.buffer.toString('base64')}`;
        
        console.log('üìÑ Base64 data info:', {
            length: slipData.length,
            firstChars: slipData.substring(0, 50) + '...',
            isValidBase64: /^[A-Za-z0-9+/]*={0,2}$/.test(slipData)
        });
        
        // Verify with ESY Slip
        console.log('üîÑ Calling ESY Slip API...');
        const verificationResult = await esySlip.verifySlip(slipData);
        
        console.log('üìä ESY Full Response:', JSON.stringify(verificationResult, null, 2));
console.log('üí∞ Raw amount:', verificationResult.amount, typeof verificationResult.amount);
console.log('üì± Raw data:', verificationResult.rawData);
        
        if (!verificationResult.success) {
            console.log('‚ùå ESY verification failed:', verificationResult.error);
            return res.status(400).json({ 
                error: verificationResult.error || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡πÑ‡∏î‡πâ',
                details: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏•‡∏¥‡∏õ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô',
                debug: {
                    apiKeyExists: !!process.env.ESY_SLIP_API_KEY,
                    fileSize: req.file.size,
                    fileType: req.file.mimetype
                }
            });
        }
        
        console.log('‚úÖ ESY verification success:', {
            amount: verificationResult.amount,
            ref: verificationResult.transactionRef,
            receiver: verificationResult.receiver,
            sender: verificationResult.sender
        });
        
        // Check if amount matches
        const tolerance = 1; // Allow 1 baht difference
        if (Math.abs(verificationResult.amount - parseFloat(expectedAmount)) > tolerance) {
            console.log('‚ùå Amount mismatch:', {
                expected: expectedAmount,
                received: verificationResult.amount
            });
            return res.status(400).json({ 
                error: `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô (‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ ${expectedAmount} ‡∏ö‡∏≤‡∏ó, ‡πÅ‡∏ï‡πà‡πÇ‡∏≠‡∏ô‡∏°‡∏≤ ${verificationResult.amount} ‡∏ö‡∏≤‡∏ó)` 
            });
        }
        
        // Check if receiver is correct
        console.log('üîç Validating receiver:', {
            slipReceiver: verificationResult.receiver,
            expectedReceiver: process.env.PROMPTPAY_ID
        });
        
        // ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ ESY API ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ
/*
if (!esySlip.validateReceiver(verificationResult, process.env.PROMPTPAY_ID)) {
    console.log('‚ùå Invalid receiver');
    return res.status(400).json({ 
        error: '‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏¥‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á' 
    });
}
*/
console.log('Warning: Skipping receiver validation - ESY cannot read receiver info');
        
        // Check duplicate payment
        console.log('üîç Checking duplicate payment...');
        const isDuplicate = await db.checkDuplicatePayment(verificationResult.transactionRef);
        if (isDuplicate) {
            console.log('‚ö†Ô∏è Duplicate payment detected');
            // Get existing payment info
            const existingPayment = await db.getPaymentByRef(verificationResult.transactionRef);
            if (existingPayment) {
                return res.json({
                    success: true,
                    isDuplicate: true,
                    message: '‡∏™‡∏•‡∏¥‡∏õ‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß',
                    transactionRef: verificationResult.transactionRef,
                    newBalance: existingPayment.current_balance,
                    verifiedAt: existingPayment.verified_at
                });
            }
        }
        
        // Get package info
        console.log('üì¶ Getting package info...');
        const packages = await db.getCreditPackages();
        const selectedPackage = packages.find(p => p.id === parseInt(packageId));
        
        if (!selectedPackage) {
            console.log('‚ùå Package not found:', packageId);
            return res.status(400).json({ 
                error: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÅ‡∏û‡πá‡∏Ñ‡πÄ‡∏Å‡∏à‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å' 
            });
        }
        
        // Calculate credits (including bonus)
        const baseCredits = parseFloat(selectedPackage.credits) || 0;
const bonusCredits = parseFloat(selectedPackage.bonus_credits) || 0;
const totalCredits = baseCredits + bonusCredits;
        console.log('üí∞ Credits to add:', {
    base: baseCredits,      // ‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡∏ó‡∏µ‡πà‡πÅ‡∏õ‡∏•‡∏á‡πÅ‡∏•‡πâ‡∏ß
    bonus: bonusCredits,    // ‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡∏ó‡∏µ‡πà‡πÅ‡∏õ‡∏•‡∏á‡πÅ‡∏•‡πâ‡∏ß
    total: totalCredits
});
        
        // Save payment and add credits
        console.log('üíæ Saving payment verification...');
        const result = await db.savePaymentVerification(
            userId,
            verificationResult.transactionRef,
            totalCredits,
            packageId,
            verificationResult.rawData
        );
        
        if (result.success) {
            console.log('üí∞ Credits added successfully:', {
                userId,
                credits: totalCredits,
                newBalance: result.newBalance
            });
            
            res.json({
                success: true,
                message: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
                transactionRef: verificationResult.transactionRef,
                creditsAdded: totalCredits,
                newBalance: result.newBalance,
                packageName: selectedPackage.name
            });
        } else {
            throw new Error('Failed to save payment');
        }
        
    } catch (error) {
        console.error('‚ùå Slip verification error:', error);
        console.error('Error stack:', error.stack);
        
        res.status(500).json({ 
            error: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà',
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
});

// ========== QR CODE GENERATION ENDPOINT ==========
app.post('/api/generate-qr', async (req, res) => {
    try {
        const { amount, promptpayId } = req.body;
        
        if (!amount || !promptpayId) {
            return res.status(400).json({ 
                error: 'Missing required parameters' 
            });
        }
        
        // Format PromptPay ID (remove dashes and spaces)
        const cleanId = promptpayId.replace(/-|\s/g, '');
        
        // Generate PromptPay payload using promptpay-qr library
        const payload = generatePayload(cleanId, { amount: parseFloat(amount) });
        
        // Generate QR Code image from payload
        const qrCodeDataUrl = await QRCode.toDataURL(payload, {
            width: 300,
            margin: 2,
            color: {
                dark: '#000000',
                light: '#FFFFFF'
            }
        });
        
        console.log('‚úÖ QR Code generated for amount:', amount);
        
        res.json({
            success: true,
            qrCode: qrCodeDataUrl,
            amount: amount,
            promptpayId: cleanId
        });
        
    } catch (error) {
        console.error('QR Code generation error:', error);
        res.status(500).json({ 
            error: 'Failed to generate QR code' 
        });
    }
});

// Health check endpoint for Railway
app.get('/health', (req, res) => {
    res.json({ status: 'healthy' });
});

// ======== ADMIN ENDPOINTS ========

// Middleware ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö admin key
function checkAdminAuth(req, res, next) {
    const adminKey = req.headers['x-admin-key'];
    
    if (!adminKey || adminKey !== ADMIN_KEY) {
        return res.status(401).json({ error: 'Unauthorized' });
    }
    
    next();
}

// Admin endpoint ‡πÄ‡∏ï‡∏¥‡∏°‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï
app.post('/api/admin/add-credits', checkAdminAuth, async (req, res) => {
    const { userId, amount, note } = req.body;
    
    if (!userId || !amount || amount <= 0) {
        return res.status(400).json({ 
            error: 'Invalid parameters' 
        });
    }
    
    try {
        const result = await db.addCredits(
            userId,
            amount,
            '‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏ú‡πà‡∏≤‡∏ô PromptPay',
            null,
            note || 'Manual credit addition'
        );
        
        if (result.success) {
            res.json({
                success: true,
                newBalance: result.newBalance,
                message: `Added ${amount} credits to ${userId}`
            });
        } else {
            res.status(400).json({ 
                error: result.error 
            });
        }
    } catch (error) {
        console.error('Error adding credits:', error);
        res.status(500).json({ 
            error: 'Failed to add credits' 
        });
    }
});

// Start server
app.listen(PORT, () => {
    console.log(`
        
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë     Veo 3 Prompt Generator Server     ‚ïë
‚ïë        with Character Support         ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

‚úÖ Server running on port ${PORT}
üìå API Key: ${process.env.OPENAI_API_KEY ? 'Configured ‚úì' : 'Not configured ‚úó'}
üìå General Assistant: ${process.env.ASSISTANT_ID ? 'Configured ‚úì' : 'Not configured ‚úó'}
üìå Character Assistant: ${process.env.CHARACTER_ASSISTANT_ID ? 'Configured ‚úì' : 'Not configured ‚úó'}
üìå Database: ${db ? 'Connected ‚úì' : 'Not connected ‚úó'}
üí∞ Daily Limit: ${DAILY_LIMIT_THB} THB per user
üì± PromptPay: ${process.env.PROMPTPAY_ID || 'Not configured'}
üí≥ ESY Slip API: ${process.env.ESY_SLIP_API_KEY ? 'Configured ‚úì' : 'Not configured ‚úó'}
üåê URL: http://localhost:${PORT}


Available Modes:
- General Prompt Generator
- Character Creator
- Character Library
- Auto Payment Verification ‚ú® NEW!
    `);
});